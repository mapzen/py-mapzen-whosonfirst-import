#!/usr/bin/env python

import sys
import signal
import multiprocessing
import os.path
import geojson
import logging

import traceback
import pprint

import mapzen.whosonfirst.concordances
import mapzen.whosonfirst.spatial

def import_feature(importer, feature, args, options):

    if options.verbose:	
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    try:

        path = importer.import_feature(feature, **args)
        logging.debug("importified %s" % path)
    except KeyboardInterrupt:
        logging.warning("Received interupt handler (in import_feature scope) so exiting")
        sys.exit()
    except Exception, e:
        logging.error("Failed to process feature because %s" % e)
        logging.debug(traceback.extract_stack())
        logging.debug("feature is a %s" % type(feature))
        logging.debug("import %s" % pprint.pformat(feature))

        raise Exception, e

if __name__ == '__main__':
    
    import optparse
    import ConfigParser

    opt_parser = optparse.OptionParser()

    opt_parser.add_option('-d', '--dest', dest='dest', action='store', default=None, help='Where to write import files')
    opt_parser.add_option('-s', '--source', dest='source', action='store', default=None, help='Source to import')

    opt_parser.add_option('-p', '--placetype', dest='place', action='store', default=None, help='A particular place type (for a source) to import')

    opt_parser.add_option('-c', '--concordances', dest='concordances', action='store_true', default=False, help='')
    opt_parser.add_option('--concordances-cfg', dest='concordances_cfg', action='store', default=None, help='')
    opt_parser.add_option('--concordances-key', dest='concordances_key', action='store', default=None, help='')

    opt_parser.add_option('-r', '--reversegeo', dest='reversegeo', action='store_true', default=False, help='')
    opt_parser.add_option('--reversegeo-cfg', dest='reversegeo_cfg', action='store', default=None, help='')

    opt_parser.add_option('-m', '--multi-processing', dest='multi', action='store_true', default=False, help='Use multiple processors (default is False)')

    opt_parser.add_option('-l', '--line-delimited', dest='line', action='store_true', default=False, help='GeoJSON is line-delimited (default is False)')
    opt_parser.add_option('-k', dest='skip', action='store_true', default=False, help='Do not overwrite existing files (default is False)')

    opt_parser.add_option('-n', '--debug', dest='debug', action='store_true', default=False, help='Enable debugging (default is false)')
    opt_parser.add_option('-v', '--verbose', dest='verbose', action='store_true', default=False, help='Be chatty (default is false)')

    options, args = opt_parser.parse_args()

    if options.verbose:	
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    obj_args = {
        'debug': options.debug
        }
            
    if options.concordances:

        obj_args['concordances'] = True

        if options.concordances_cfg:

            cfg = ConfigParser.ConfigParser()
            cfg.read(options.concordances_cfg)

            dsn = mapzen.whosonfirst.concordances.cfg2dsn(cfg, 'concordances')
            obj_args['concordances_dsn'] = dsn

        else:
            logging.error("Missing concordances DSN or config")
            sys.exit()

        if options.concordances_key:
            obj_args['concordances_key'] = options.concordances_key
        else:
            logging.error("Missing concordances key")
            sys.exit()

    # spatial (reversegeo) lookups

    if options.reversegeo:

        obj_args['reversegeo'] = True

        if options.reversegeo_cfg:

            cfg = ConfigParser.ConfigParser()
            cfg.read(options.reversegeo_cfg)

            dsn = mapzen.whosonfirst.spatial.cfg2dsn(cfg, 'whosonfirst')
            obj_args['reversegeo_dsn'] = dsn

        else:
            logging.error("Missing reverse geo DSN or config")
            sys.exit()

    # specific importer args

    import_args = {
        'skip_existing': options.skip
        }

    dest = os.path.abspath(options.dest)

    if options.source == 'openvenues':

        import mapzen.whosonfirst.importer.openvenues
        imprtr = mapzen.whosonfirst.importer.openvenues.importer(dest, **obj_args)

    elif options.source == 'simplegeo':

        import mapzen.whosonfirst.importer.simplegeo
        imprtr = mapzen.whosonfirst.importer.simplegeo.importer(dest, **obj_args)

    elif options.source == 'naturalearth':

        import mapzen.whosonfirst.importer.naturalearth

        if options.place == 'marine':

            imprtr = mapzen.whosonfirst.importer.naturalearth.marine_importer(dest, **obj_args)

        else:
            logging.error("Invalid place or missing placetype")
            sys.exit()

    elif options.source == 'quattroshapes':

        import mapzen.whosonfirst.importer.quattroshapes

        if options.place == 'country' or options.place == 'adm0':
            imprtr = mapzen.whosonfirst.importer.quattroshapes.adm0_importer(dest, **obj_args)

        elif options.place == 'region' or options.place == 'adm1':
            imprtr = mapzen.whosonfirst.importer.quattroshapes.adm1_importer(dest, **obj_args)

        elif options.place == 'macroregion' or options.place == 'adm1_region':
            imprtr = mapzen.whosonfirst.importer.quattroshapes.adm1_region_importer(dest, **obj_args)

        elif options.place == 'county' or options.place == 'adm2':
            imprtr = mapzen.whosonfirst.importer.quattroshapes.adm2_importer(dest, **obj_args)

        elif options.place == 'macrocounty' or options.place == 'adm2_region':
            imprtr = mapzen.whosonfirst.importer.quattroshapes.adm2_region_importer(dest, **obj_args)

        elif options.place == 'localadmin':
            imprtr = mapzen.whosonfirst.importer.quattroshapes.localadmin_importer(dest, **obj_args)

        elif options.place == 'locality':
            imprtr = mapzen.whosonfirst.importer.quattroshapes.locality_importer(dest, **obj_args)

        elif options.place == 'neighbourhood' or options.place == 'neighborhood':
            imprtr = mapzen.whosonfirst.importer.quattroshapes.neighbourhood_importer(dest, **obj_args)

        elif options.place == 'concordances':
            imprtr = mapzen.whosonfirst.importer.quattroshapes.concordances_importer(dest, **obj_args)

        else:
            logging.error("Invalid place or missing placetype")
            sys.exit()

    elif options.source == 'custom':

        import mapzen.whosonfirst.importer.custom
            
        if options.place == 'gowanusheights':
            imprtr = mapzen.whosonfirst.importer.custom.gowanusheights_importer(dest, **obj_args)

        elif options.place == 'lalengua':
            imprtr = mapzen.whosonfirst.importer.custom.lalengua_importer(dest, **obj_args)

        elif options.place == 'minitenders':
            imprtr = mapzen.whosonfirst.importer.custom.minitenders_importer(dest, **obj_args)

        else:
            logging.error("Invalid place or missing placetype")
            sys.exit()
            
    elif options.source == 'woedb':

        import mapzen.whosonfirst.importer.woedb

        if options.place == 'timezone':
            imprtr = mapzen.whosonfirst.importer.woedb.timezone_importer(dest, **obj_args)

        elif options.place == 'airport':
            imprtr = mapzen.whosonfirst.importer.woedb.airport_importer(dest, **obj_args)

        else:
            logging.error("Invalid place or missing placetype")
            sys.exit()

        root = args[0]
        args = []

        for (path, dirs, files) in os.walk(root):

            for f in files:

                f = os.path.join(path, f)
                f = os.path.abspath(f)
                args.append(f)

    else:
        logging.error("Unknown or invalid source to import")
        sys.exit()

    for file in args:

        path = os.path.abspath(file)
        logging.info("reading %s" % path)

        if options.multi:
            processes = multiprocessing.cpu_count() * 2
            pool = multiprocessing.Pool(processes=processes)

            logging.debug("create new multiprocessing pool with %s processers" % processes)

            def sigint_handler(signum, frame):
                logging.warning("Received interupt handler (in pool scope) so exiting")
                pool.terminate()
                sys.exit()

            signal.signal(signal.SIGINT, sigint_handler)

        fh = open(path, 'r')

        if options.line:

            for ln in fh.readlines():

                try:
                    data = geojson.loads(ln)
                except Exception, e:
                    logging.error("failed to read ln, because %s" % e)
                    logging.debug(ln)
                    continue

                if options.multi:
                    pool.apply_async(import_feature, (imprtr, data, import_args, options))
                else:
                    import_feature(imprtr, data, import_args, options)
                    
        else:

            try:
                data = geojson.load(fh)
            except Exception, e:
                logging.error("failed to read %s, because %s" % (path, e))
                continue

            for f in data['features']:

                if not f['geometry']:
                    logging.error("feature is missing a geometry")
                    continue

                if options.multi:
                    pool.apply_async(import_feature, (imprtr, f, import_args, options))
                else:
                    import_feature(imprtr, f, import_args, options)

        if options.multi:
            pool.close()
            pool.join()

    sys.exit()
